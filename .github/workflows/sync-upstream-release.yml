name: sync-upstream-release

on:
  schedule:
    - cron: "13 2 * * *"
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  sync-release:
    runs-on: ubuntu-latest
    env:
      UPSTREAM_OWNER: vegu-ai
      UPSTREAM_REPO: talemate
    steps:
      - name: Sync fork and latest upstream release
        uses: actions/github-script@v7
        with:
          script: |
            const upstreamOwner = process.env.UPSTREAM_OWNER;
            const upstreamRepo = process.env.UPSTREAM_REPO;
            const { owner, repo } = context.repo;

            const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
            const defaultBranch = repoInfo.default_branch;

            const { data: upstreamRelease } = await github.rest.repos.getLatestRelease({
              owner: upstreamOwner,
              repo: upstreamRepo,
            });

            const tag = upstreamRelease.tag_name;
            if (!tag) {
              core.setFailed("Upstream release is missing a tag_name.");
              return;
            }

            const upstreamRef = `${upstreamOwner}:${defaultBranch}`;
            const { data: existingPRs } = await github.rest.pulls.list({
              owner,
              repo,
              state: "open",
              head: upstreamRef,
              base: defaultBranch,
            });

            if (existingPRs.length > 0) {
              core.info("Upstream sync PR already open.");
              core.info("Skipping release mirror until upstream sync PR is merged.");
              return;
            }

            const { data: compare } = await github.rest.repos.compareCommits({
              owner,
              repo,
              base: `${upstreamOwner}:${tag}`,
              head: `${owner}:${defaultBranch}`,
            });

            if (compare.status === "behind" || compare.status === "diverged") {
              await github.rest.pulls.create({
                owner,
                repo,
                title: `Sync upstream ${upstreamOwner}/${upstreamRepo}:${defaultBranch}`,
                head: upstreamRef,
                base: defaultBranch,
                body:
                  "Automated upstream sync PR. Merge this to update the fork before mirroring releases.",
              });
              core.info(`Opened upstream sync PR from ${upstreamRef} to ${defaultBranch}.`);
              core.info("Skipping release mirror until upstream sync PR is merged.");
              return;
            }

            try {
              await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              core.info(`Release ${tag} already exists in ${owner}/${repo}.`);
              return;
            } catch (error) {
              if (error.status !== 404) throw error;
            }

            const targetCommitish = upstreamRelease.target_commitish || tag;
            try {
              await github.rest.repos.getCommit({
                owner,
                repo,
                ref: targetCommitish,
              });
            } catch (error) {
              core.setFailed(
                `Fork is missing upstream commitish "${targetCommitish}". Sync the fork before releasing.`
              );
              return;
            }

            await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name: tag,
              name: upstreamRelease.name || tag,
              body: upstreamRelease.body || "",
              prerelease: upstreamRelease.prerelease,
              draft: false,
              target_commitish: targetCommitish,
            });

            core.info(`Created release ${tag} in ${owner}/${repo}.`);
